<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°</title>
  <style>
    body{background:#0b0b0b;color:#fff;font-family:"Noto Sans KR",sans-serif;padding:18px}
    h1{margin:0 0 12px}
    .muted{opacity:.7;font-size:12px}
    .row{display:flex;gap:14px;flex-wrap:wrap;margin:12px 0}
    .stat{flex:1;min-width:220px;background:#0f0f0f;border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px}
    .label{opacity:.75;font-weight:900;font-size:12px}
    .value{font-weight:900;font-size:22px;margin-top:4px}
    .grid{display:grid;grid-template-columns:1fr;gap:14px}
    .card{background:#111;border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:14px}
    canvas{width:100%;height:240px}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.08);text-align:left;font-size:12px}
    th{opacity:.8}
    .right{text-align:right}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  </style>
</head>
<body>
  <h1>ğŸ–¥ï¸ ì‹œìŠ¤í…œ ìì›(ì‹¤ì‹œê°„)</h1>
  <div class="muted">CPU(ì „ì²´/ì½”ì–´ë³„), ë©”ëª¨ë¦¬, ë„¤íŠ¸ì›Œí¬ ì—…/ë‹¤ìš´, TOP í”„ë¡œì„¸ìŠ¤ë¥¼ 1ì´ˆë§ˆë‹¤ ê°±ì‹ í•©ë‹ˆë‹¤.</div>

  <div class="row">
    <div class="stat">
      <div class="label">CPU(ì „ì²´)</div>
      <div id="cpuVal" class="value">--%</div>
    </div>
    <div class="stat">
      <div class="label">ë©”ëª¨ë¦¬</div>
      <div id="memVal" class="value">--%</div>
      <div id="memBytes" class="muted"></div>
    </div>
    <div class="stat">
      <div class="label">ë„¤íŠ¸ì›Œí¬</div>
      <div class="muted">UP <span id="netUp" class="mono">--</span> / DOWN <span id="netDown" class="mono">--</span></div>
      <div class="muted">DISK <span id="diskVal" class="mono">--</span></div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="label">CPU ì „ì²´(%)</div>
      <canvas id="cpuChart"></canvas>
    </div>

    <div class="card">
      <div class="label">CPU ì½”ì–´ë³„(%)</div>
      <canvas id="coreChart"></canvas>
    </div>

    <div class="card">
      <div class="label">ë©”ëª¨ë¦¬(%)</div>
      <canvas id="memChart"></canvas>
    </div>

    <div class="card">
      <div class="label">ë„¤íŠ¸ì›Œí¬(ì—…/ë‹¤ìš´ KB/s)</div>
      <canvas id="netChart"></canvas>
    </div>

    <div class="card">
      <div class="label">TOP í”„ë¡œì„¸ìŠ¤ (CPU / MEM)</div>
      <table>
        <thead>
          <tr>
            <th>PID</th>
            <th>NAME</th>
            <th class="right">CPU%</th>
            <th class="right">MEM(MB)</th>
          </tr>
        </thead>
        <tbody id="procBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Chart.js CDN (ì˜¤í”„ë¼ì¸ í•„ìš”í•˜ë©´ ë¡œì»¬ íŒŒì¼ë¡œ ë°”ê¾¸ì„¸ìš”) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    const MAX_POINTS = 60; // 60ì´ˆ
    const labels = [];
    const cpuData = [];
    const memData = [];
    const upData = [];
    const downData = [];

    let coreDatasets = [];
    let coreChart = null;

    function fmtBytes(b){
      const u = ["B","KB","MB","GB","TB"];
      let i=0, n=b;
      while(n>=1024 && i<u.length-1){ n/=1024; i++; }
      return `${n.toFixed(1)} ${u[i]}`;
    }
    function fmtRate(bps){
      const kb = bps / 1024;
      if (kb < 1024) return `${kb.toFixed(1)} KB/s`;
      return `${(kb/1024).toFixed(2)} MB/s`;
    }

    function mkLine(ctx, label, dataArr){
      return new Chart(ctx, {
        type: "line",
        data: { labels, datasets: [{ label, data: dataArr, tension: 0.25 }] },
        options: {
          responsive: true,
          animation: false,
          scales: {
            y: { min: 0, max: 100, ticks: { color:"#bbb" }, grid: { color:"rgba(255,255,255,0.06)" } },
            x: { ticks: { color:"#888" }, grid: { display:false } }
          },
          plugins: { legend: { labels: { color:"#ddd" } } }
        }
      });
    }

    const cpuChart = mkLine(document.getElementById("cpuChart"), "CPU", cpuData);
    const memChart = mkLine(document.getElementById("memChart"), "MEM", memData);

    const netChart = new Chart(document.getElementById("netChart"), {
      type: "line",
      data: {
        labels,
        datasets: [
          { label: "UP (KB/s)", data: upData, tension: 0.25 },
          { label: "DOWN (KB/s)", data: downData, tension: 0.25 }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        scales: {
          y: { ticks: { color:"#bbb" }, grid: { color:"rgba(255,255,255,0.06)" } },
          x: { ticks: { color:"#888" }, grid: { display:false } }
        },
        plugins: { legend: { labels: { color:"#ddd" } } }
      }
    });

    function ensureCoreChart(coreCount){
      if (coreChart && coreDatasets.length === coreCount) return;

      coreDatasets = Array.from({length: coreCount}, (_, i) => ({
        label: `C${i}`,
        data: [],
        tension: 0.25
      }));

      if (coreChart) coreChart.destroy();

      coreChart = new Chart(document.getElementById("coreChart"), {
        type: "line",
        data: { labels, datasets: coreDatasets },
        options: {
          responsive: true,
          animation: false,
          scales: {
            y: { min:0, max:100, ticks:{ color:"#bbb" }, grid:{ color:"rgba(255,255,255,0.06)" } },
            x: { ticks:{ color:"#888" }, grid:{ display:false } }
          },
          plugins: { legend: { labels: { color:"#ddd" } } }
        }
      });
    }

    function pushPoint(label, cpu, mem, upKB, downKB, cores){
      labels.push(label);
      cpuData.push(cpu);
      memData.push(mem);
      upData.push(upKB);
      downData.push(downKB);

      ensureCoreChart(cores.length);
      cores.forEach((v, i) => coreDatasets[i].data.push(v));

      if (labels.length > MAX_POINTS){
        labels.shift();
        cpuData.shift();
        memData.shift();
        upData.shift();
        downData.shift();
        coreDatasets.forEach(ds => ds.data.shift());
      }
    }

    function renderProcs(arr){
      const body = document.getElementById("procBody");
      if (!body) return;
      body.innerHTML = (arr || []).map(p => `
        <tr>
          <td class="mono">${p.pid}</td>
          <td>${(p.name || "").replaceAll("<","&lt;").replaceAll(">","&gt;")}</td>
          <td class="right mono">${(p.cpu ?? 0).toFixed ? p.cpu.toFixed(1) : p.cpu}</td>
          <td class="right mono">${(p.mem_mb ?? 0).toFixed ? p.mem_mb.toFixed(1) : p.mem_mb}</td>
        </tr>
      `).join("");
    }

    async function tick(){
      try{
        const res = await fetch("/api/metrics?t=" + Date.now(), { cache:"no-store" });
        const m = await res.json();

        const now = new Date(m.ts * 1000);
        const tlabel = now.toLocaleTimeString("ko-KR", { hour12:false });

        const cpu = Number(m.cpu || 0);
        const mem = Number(m.mem || 0);
        const upKB = Number((m.net_up_bps || 0) / 1024);
        const downKB = Number((m.net_down_bps || 0) / 1024);
        const cores = Array.isArray(m.cpu_percore) ? m.cpu_percore.map(Number) : [];

        pushPoint(tlabel, cpu, mem, upKB, downKB, cores);

        document.getElementById("cpuVal").textContent = `${Math.round(cpu)}%`;
        document.getElementById("memVal").textContent = `${Math.round(mem)}%`;
        document.getElementById("memBytes").textContent = `${fmtBytes(m.mem_used)} / ${fmtBytes(m.mem_total)}`;

        document.getElementById("netUp").textContent = fmtRate(m.net_up_bps || 0);
        document.getElementById("netDown").textContent = fmtRate(m.net_down_bps || 0);

        document.getElementById("diskVal").textContent =
          (m.disk == null) ? "--" : `${Math.round(m.disk)}%`;

        cpuChart.update();
        memChart.update();
        netChart.update();
        coreChart && coreChart.update();

        renderProcs(m.top_procs || []);
      }catch(e){
        // ëŠê¹€ì‹œ ì¡°ìš©íˆ ìœ ì§€
      }
    }

    setInterval(tick, 1000);
    tick();
  </script>
</body>
</html>
